/**
 * The Contact class represents an individual contact with the personal details specified in the rubric.
 *
 * Each contact is assigned a unique ID upon creation, which is generated by the ContactService.
 * The contact also stores the first name, last name, phone number, and address, all of which
 * must pass validation checks before being assigned.
 *
 * If any validation fails, an IllegalArgumentException is thrown, preventing the creation of invalid contacts.
 * Methods for setting fields validate the incoming values when called.
 */
public class Contact {
    private final String Id;

    private String firstName;

    private String lastName;

    private String phone;

    private String address;

    /**
     * Constructs a new Contact object with the given first name, last name, phone number, and address.
     * If all validations pass, contact is added to the ContactService.
     */
    public Contact(String firstName, String lastName, String phone, String address) {

        // contact service creates a unique ID. call method here and use value.
        this.Id = ContactService.getInstance().getUniqueContactId();

        boolean firstNameIsValid = tryRegisterName(firstName, true);

        boolean lastNameIsValid = tryRegisterName(lastName, false);

        boolean phoneIsValid = tryRegisterPhone(phone);

        boolean addressIsValid = tryRegisterAddress(address);

        if (firstNameIsValid && lastNameIsValid && phoneIsValid && addressIsValid) {
            ContactService.getInstance().addContact(this);
        }
    }


    /*
     * Each field (firstName, lastName, phone, address) is validated using
     * their respective `tryRegister` and `validate` methods.
     * - The `tryRegister` methods attempt to assign values.
     * - The `validate` methods perform checks.
     * - If validation fails, an IllegalArgumentException gets thrown, and field is not updated.
     *
     * As a note, I wrote try/catch blocks before creating the Junit tests. I made the catch blocks throw the same
     * exceptions again, rather than removing the blocks themselves.
     *
     * Also, the requirements for valid first names is exactly the same as those for last names, so they both
     * are validated/registered via tryRegisterName.
     */

    private boolean tryRegisterName(String name, boolean isFirstName) {
        boolean success = false;

        try {
            if (isFirstName) {
                this.firstName = validateName(name, true).trim();
            } else {
                this.lastName = validateName(name, false).trim();
            }
            success = true;
        } catch (IllegalArgumentException illegalArg) {
            throw new IllegalArgumentException(illegalArg.getMessage());
        }
        return success;
    }

    private String validateName(String name, boolean isFirstName) {
        // firstName String field that cannot be longer than 10 characters. The firstName field shall not be null.
        if (name == null || name.trim().isEmpty()) {
            if (isFirstName) {
                throw new IllegalArgumentException("firstName '" + name + "' is null or empty String");
            }
            throw new IllegalArgumentException("lastName '" + name + "' is null or empty String");
        }

        // remove whitespace if any.
        name = name.trim();

        // check length of name. exception if longer than 10 chars.
        if (name.length() > 10) {
            String msg = "length of name '" + name + "' exceeds 10 characters";
            throw new IllegalArgumentException(msg);
        }

        // exception if name contains any non-alphabetical char
        for (char c : name.toCharArray()) {
            if (!Character.isAlphabetic(c)) {
                String msg = "name '" + name + "' contains non-alphabetical character";
                throw new IllegalArgumentException(msg);
            }
        }

        return name;
    }


    private boolean tryRegisterPhone(String phone) {
        boolean success = false;
        try {
            this.phone = validatePhone(phone);
            success = true;
        } catch (IllegalArgumentException illegalArg) {
            throw new IllegalArgumentException(illegalArg.getMessage());
        }
        return success;
    }

    private String validatePhone(String phone) {
        //required phone String field must be exactly 10 digits. The phone field shall not be null.
        if (phone == null || phone.trim().length() != 10) {
            String msg;
            if (phone == null) {
                msg = "phone field is null";
            } else if (phone.trim().isEmpty()) {
                msg = "phone field is an empty string";
            } else {
                msg = "phone string is not exactly 10 characters in length";
            }
            throw new IllegalArgumentException(msg);
        }

        // trim whitespace if any
        phone = phone.trim();

        // ensure phone string only consists of numerical chars
        for (char c : phone.toCharArray()) {
            if (!Character.isDigit(c)) {
                String msg = "phone string contains non-numerical characters";
                throw new IllegalArgumentException(msg);
            }
        }

        return phone;
    }


    private boolean tryRegisterAddress(String address) {
        boolean success = false;
        try {
            this.address = validateAddress(address);
            success = true;
        } catch (IllegalArgumentException illegalArg) {
            System.out.println(illegalArg.getClass().getName() + ": " + illegalArg.getMessage());
            throw new IllegalArgumentException();
        }
        return success;
    }

    private String validateAddress(String address) {
        //required address field must be no longer than 30 characters. The address field shall not be null.
        if (address == null || address.trim().length() > 30) {
            String msg = address == null ? "address field is null" : "address String exceeds 30 characters in length";
            throw new IllegalArgumentException(msg);
        }

        address = address.trim();

        if (address.isEmpty()){
            throw new IllegalArgumentException("address field is an empty string");
        }
        // the checks required in the rubric seem insufficient. To be sure that a valid address is entered,
        // I would think creating an Address class with its own validators would be a better approach.
        // however the only criteria given for a valid address in the rubric are that
        // it cannot be null, and it cannot be longer than 30 chars, so as far as I went
        // with additional checks is to make sure address is not an empty/whitespace-only string.
        return address.trim();
    }


    // getters
    public String getId() {
        return this.Id;
    }

    public String getFirstName() {
        return this.firstName;
    }

    public String getLastName() {
        return this.lastName;
    }

    public String getPhone() {
        return this.phone;
    }

    public String getAddress() {
        return this.address;
    }

    // setters
    public void setFirstName(String name) {
        tryRegisterName(name, true);
    }

    public void setLastName(String name) {
        tryRegisterName(name, false);
    }

    public void setPhone(String phone) {
        tryRegisterPhone(phone);
    }

    public void setAddress(String address) {
        tryRegisterAddress(address);
    }

    // debug print method.
    public void printInfo() {
        System.out.println("-----------------Contact printInfo()-----------------");
        System.out.println("Contact Information");
        System.out.println("Contact Id: " + this.getId());
        System.out.println("Contact First Name: " + this.getFirstName());
        System.out.println("Contact Last Name: " + this.getLastName());
        System.out.println("Contact Phone: " + this.getPhone());
        System.out.println("Contact Address: " + this.getAddress());
        System.out.println("------------------------------------------------------------------------");
    }

}
